import Foundation
import SwiftData

final class {{entity}}PullService {
    private let modelContext: ModelContext
    private let userId: UUID
    private let user: User

    init(modelContext: ModelContext, user: User) {
        self.modelContext = modelContext
        self.user = user
        self.userId = user.id
    }

    @MainActor
    func pullAndMerge{{entity}}s() async throws {
        print("[{{entity}}PullService] üöÄ Starting pullAndMerge{{entity}}s")

        guard let token = TokenProvider.shared.getToken() else {
            print("[{{entity}}PullService] ‚ùå No token found")
            throw AppError.missingToken
        }

        let url = API{{entity}}.queryEndpoint
        print("[{{entity}}PullService] üåê Fetching from: \(url.absoluteString)")

        var request = URLRequest(url: url)
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")

        let (data, response) = try await URLSession.shared.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            print("[{{entity}}PullService] ‚ùå Invalid HTTP response")
            throw URLError(.badServerResponse)
        }

        print("[{{entity}}PullService] üì° HTTP Status: \(httpResponse.statusCode)")

        if !(200..<300).contains(httpResponse.statusCode) {
            let raw = String(data: data, encoding: .utf8) ?? "No response body"
            print("[{{entity}}PullService] ‚ùå Server error: \(raw)")
            throw AppError.server(raw)
        }

        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .custom { decoder in
            let container = try decoder.singleValueContainer()
            let dateString = try container.decode(String.self)
            let formats = [
                "yyyy-MM-dd'T'HH:mm:ss.SSSSSSZ",
                "yyyy-MM-dd'T'HH:mm:ss.SSSZ",
                "yyyy-MM-dd'T'HH:mm:ssZ"
            ]
            for format in formats {
                let formatter = DateFormatter()
                formatter.dateFormat = format
                formatter.locale = Locale(identifier: "en_US_POSIX")
                formatter.timeZone = TimeZone(secondsFromGMT: 0)
                if let date = formatter.date(from: dateString) {
                    return date
                }
            }
            throw DecodingError.dataCorruptedError(
                in: container,
                debugDescription: "Cannot decode date: \(dateString)"
            )
        }

        do {
            let remote = try decoder.decode({{entity}}PagedResponse.self, from: data)


            let existing = try modelContext.fetch(
                FetchDescriptor<{{entity}}>(
                    predicate: #Predicate { $0.user?.id == userId }
                )
            )
            print("[{{entity}}PullService] ‚úÖ Remote items: \(remote.content.count)")
            print("[{{entity}}PullService] üóÇ _Local items: \(existing.count)")

            for remoteItem in remote.content {
                if let index = existing.firstIndex(where: { $0.reference == remoteItem.reference }) {
                        let attached = existing[index]

                    if let remoteUpdatedAt = remoteItem.updatedAt,
                       let localUpdatedAt = attached.updatedAt,
                       remoteUpdatedAt <= localUpdatedAt && attached.statusRaw != {{entity}}Status.syncing.rawValue
                        {
                            attached.remoteId = remoteItem.id
                            print("[{{entity}}PullService] ‚è© Skipped: \(attached.name)")
                            print(" localUpdatedAt \(localUpdatedAt) vs remoteUpdatedAt \(remoteUpdatedAt)")

                        continue
                    }


                    {{#fields}}
    {{^isId}}
        {{^isParentRelation}}
                    attached.{{name}} = remoteItem.{{name}}
        {{/isParentRelation}}
    {{/isId}}
{{/fields}}
                    attached.status = {{entity}}Status.sync
                    attached.statusRaw = {{entity}}Status.sync.rawValue

                    print("[{{entity}}PullService] üîÑ Updating: \(attached.name) to  \(attached.statusRaw)")

                    attached.syncAt = Date()
                } else {
                    print("[{{entity}}PullService] ‚ûï Creating new: \(remoteItem.name)")
                    let newItem = {{entity}}(
                        {{#fields}}
    {{^isId}}
        {{name}}: remoteItem.{{name}},
    {{/isId}}
{{/fields}}
                    )
                    newItem.user = user
                    newItem.remoteId = remoteItem.id
                    newItem.syncAt = Date()
                    newItem.status = {{entity}}Status.sync
                    newItem.statusRaw = {{entity}}Status.sync.rawValue
                    modelContext.insert(newItem)
                }
            }

            try modelContext.save()
            print("[{{entity}}PullService] üíæ Saved")
        } catch {
            let raw = String(data: data, encoding: .utf8) ?? "<no body>"
            print("[{{entity}}PullService] ‚ùå Decode error: \(error)")
            print("[{{entity}}PullService] ‚ùå Raw: \(raw)")
            throw error
        }
    }
}
