import SwiftUI
import SwiftData

final class {{entity}}ListViewModel: ObservableObject {
var modelContext: ModelContext
var user: User
let username: String

@Published var entities: [{{entity}}] = []
@Published var errorMessage: String?
@Published var isLoading: Bool = false
@Published var showSuccessToast = false
@Published var showErrorToast = false
@Published var searchText: String = ""
@Published var searchCriteria: {{entity}}SearchCriteria = .name
@Published var showAdd{{entity}}Sheet = false
@Published var showExportSheet = false
@Published var showSyncToCloudSheet = false
@Published var showAddSearchSheet = false
@Published var showSettingsSheet = false

{{#header}}
@Published var current{{headerUpperCase}}Id: String?
@Published var current{{headerUpperCase}} : {{headerUpperCase}}?
{{/header}}

    @Published var selectedStartDate: Date?
    @Published var selectedEndDate: Date?



    init(modelContext: ModelContext, user: User) {
        self.modelContext = modelContext
        self.user = user
        self.username = user.username!
        }
{{#hasType}}
  func fixType{{entity}}RawIfMissing() {
        for {{entityLowerCase}} in entities where {{entityLowerCase}}.type{{entity}}Raw.isEmpty {
            {{entityLowerCase}}.type{{entity}}Raw = {{entity}}Type.type1.rawValue
        }
        try? modelContext.save()
    }
{{/hasType}}

var filtered{{entity}}s: [{{entity}}] {
    entities
        .filter { $0.deletedAt == nil }
        {{#header}}
        .filter {
            current{{headerUpperCase}}Id == nil || $0.{{headerLowerCase}}LocalId == current{{headerUpperCase}}Id
        }
        .filter {
        {{^hasDate}}
            guard let date = $0.updatedAt,
            {{/hasDate}}
            {{#hasDate}}
            guard let date = $0.date{{entity}},
            {{/hasDate}}
                let sd = selectedStartDate,
                let ed = selectedEndDate
            else { return true }
            return date >= sd && date <= ed
        }
        {{/header}}
}

 func fetchEntities() {
        print("[fetchEntities]")
        
        isLoading = true
        let cond = "{{entity}}Status.delete".uppercased()
        let descriptor = FetchDescriptor<{{entity}}>(
            predicate: #Predicate { item in
                item.user?.username == username && item.statusRaw != cond
            },
            {{^hasDate}}
            sortBy: [SortDescriptor(\.updatedAt, order: .reverse)]
            {{/hasDate}}
            {{#hasDate}}
            sortBy: [SortDescriptor(\.date{{entity}}, order: .reverse)]
            {{/hasDate}}
        )
        do {
            entities = try modelContext.fetch(descriptor)
        } catch {
            errorMessage = mapError(error)
        }
        isLoading = false
    }
{{#header}}
    func fetchEntitiesBy{{headerUpperCase}}({{headerLowerCase}}Id: String?) {
        print("[fetchEntitiesBy{{headerUpperCase}}]")
        print({{headerLowerCase}}Id)
        isLoading = true
        let cond = "{{entity}}Status.delete".uppercased()
        let descriptor = FetchDescriptor<{{entity}}>(
            predicate: #Predicate { item in
                item.user?.username == username && item.statusRaw != cond
                     && item.{{headerLowerCase}} != nil
                    && ( item.{{headerLowerCase}}LocalId == {{headerLowerCase}}Id
                    || item.{{headerLowerCase}}LocalId == {{headerLowerCase}}Id )
            },
            {{^hasDate}}
            sortBy: [SortDescriptor(\.updatedAt, order: .reverse)]
            {{/hasDate}}
            {{#hasDate}}
            sortBy: [SortDescriptor(\.date{{entity}}, order: .reverse)]
            {{/hasDate}}
        )
        do {
            entities = try modelContext.fetch(descriptor)
        } catch {
            errorMessage = mapError(error)
        }
        isLoading = false
    }
{{/header}}

func createEntity(
{{#fields}}
{{^isId}}
{{name}}: {{realType}}{{#nullable}}? = nil{{/nullable}}{{^nullable}}{{#defaultValue}} = {{{defaultValue}}}{{/defaultValue}}{{/nullable}},
{{/isId}}
{{#isManyToOne}}
{{name}}LocalId: String? = nil,
{{/isManyToOne}}
{{/fields}}
) {
let item = {{entity}}(
{{#fields}}
{{^isId}}
{{name}}: {{name}},
{{/isId}}
{{/fields}}
)
item.user = user
item.reference = item.id

{{#fields}}
{{#isManyToOne}}
item.{{name}}LocalId = {{name}}LocalId
{{/isManyToOne}}
{{/fields}}

print("createEntity \(item.name)")
modelContext.insert(item)
saveContext()
}

func updateEntity(_ item: {{entity}},
{{#fields}}
	{{name}}: {{realType}},
    {{#isManyToOne}}
    {{name}}LocalId: String? = nil,
    {{/isManyToOne}}
{{/fields}}
) {
{{#fields}}
	item.{{name}} = {{name}}{{#isLowerCase}}.lowercased(){{/isLowerCase}}
{{#isManyToOne}}
    item.{{name}}LocalId = {{name}}LocalId
{{/isManyToOne}}
{{/fields}}

if item.remoteId == nil {
print("[updateEntity] remoteId is nil  \(item.name)")
item.status = .create
} else {
print("[updateEntity] local ok \(item.name)")
item.status = .update
}

item.reference = item.id
item.user = user
print("updated \(item.name)")
item.updatedAt = Date()
item.syncAt = nil
print("updateEntity \(item.name)")
saveContext()
}

func deleteEntity(_ item: {{entity}}) {
item.status = .delete
item.deletedAt = Date()
item.updatedAt = Date()
item.syncAt = nil

if item.remoteId == nil {
item.remoteId = "NOT_EXIST_YET"
print("Deleted \(item.name)")
modelContext.delete(item)
} else {
item.status = .delete
}

item.user = user
print("deleteEntity \(item.name)")
saveContext()
}

public func saveContext() {
do {
try modelContext.save()
} catch {
errorMessage = mapError(error)
}
}

 func search{{entity}}s(text: String, by criteria: {{entity}}SearchCriteria) {
        guard !text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            fetchEntities()
            return
        }

        isLoading = true
        let cond = "{{entity}}Status.delete".uppercased()

        let commonPredicate: ({{entity}}) -> Bool = { item in
            guard let username = item.user?.username,
                  username == self.username,
                  item.statusRaw != cond else {
                return false
            }

{{#header}}
            let matches{{headerUpperCase}} = self.current{{headerUpperCase}}Id == nil ||
            item.{{headerLowerCase}} == self.current{{headerUpperCase}}Id ||
            item.{{headerLowerCase}}LocalId == self.current{{headerUpperCase}}Id
{{/header}}
            let matchesDate: Bool
            if let sd = self.selectedStartDate, let ed = self.selectedEndDate
            {{#hasDate}}, let date = item.date{{entity}} {{/hasDate}}
            {{^hasDate}}, let date = item.updatedAt {{/hasDate}}
             {
                matchesDate = date >= sd && date <= ed
            } else {
                matchesDate = true
            }

            let matchesText: Bool
            switch criteria {

            {{#fieldsDisplayed}}
             case .{{nameLowerCase}}:
                matchesText = item.{{nameLowerCase}}.localizedStandardContains(text) ?? false
            {{/fieldsDisplayed}}

            @unknown default:
                matchesText = false
            }

            return {{#header}} matches{{headerUpperCase}} && {{/header}}  matchesDate && matchesText
        }

        do {
            entities = try modelContext.fetch(FetchDescriptor<{{entity}}>()).filter(commonPredicate)
        } catch {
            errorMessage = mapError(error)
        }

        isLoading = false
    }



}
