import SwiftUI
import SwiftData

final class {{entity}}ListViewModel: ObservableObject {
var modelContext: ModelContext
var user: User
let username: String

@Published var entities: [{{entity}}] = []
@Published var errorMessage: String?
@Published var isLoading: Bool = false
@Published var showSuccessToast = false
@Published var showErrorToast = false
@Published var searchText: String = ""
@Published var searchCriteria: {{entity}}SearchCriteria = .name
@Published var showAdd{{entity}}Sheet = false
@Published var showExportSheet = false
@Published var showSyncToCloudSheet = false
@Published var showAddSearchSheet = false
@Published var showSettingsSheet = false

{{#header}}
@Published var current{{headerUpperCase}}Id: String?
{{/header}}


init(modelContext: ModelContext, user: User) {
self.modelContext = modelContext
self.user = user
self.username = user.username!
}

 func fetchEntities() {
        print("[fetchEntities]")
        
        isLoading = true
        let cond = "{{entity}}Status.delete".uppercased()
        let descriptor = FetchDescriptor<{{entity}}>(
            predicate: #Predicate { item in
                item.user?.username == username && item.statusRaw != cond
            },
            sortBy: [SortDescriptor(\.updatedAt, order: .reverse)]
        )
        do {
            entities = try modelContext.fetch(descriptor)
        } catch {
            errorMessage = mapError(error)
        }
        isLoading = false
    }
{{#header}}
    func fetchEntitiesBy{{headerUpperCase}}(accountId: String?) {
        print("[fetchEntitiesBy{{headerUpperCase}}]")
        print(accountId)
        isLoading = true
        let cond = "{{entity}}Status.delete".uppercased()
        let descriptor = FetchDescriptor<{{entity}}>(
            predicate: #Predicate { item in
                item.user?.username == username && item.statusRaw != cond
                     && item.{{headerLowerCase}} != nil
                    && ( item.{{headerLowerCase}} == {{headerLowerCase}}Id
                    || item.{{headerLowerCase}}LocalId == {{headerLowerCase}}Id )
            },
            sortBy: [SortDescriptor(\.updatedAt, order: .reverse)]
        )
        do {
            entities = try modelContext.fetch(descriptor)
        } catch {
            errorMessage = mapError(error)
        }
        isLoading = false
    }
{{/header}}

func createEntity(
{{#fields}}
{{^isId}}
{{name}}: {{realType}}{{#nullable}}? = nil{{/nullable}}{{^nullable}}{{#defaultValue}} = {{{defaultValue}}}{{/defaultValue}}{{/nullable}},
{{/isId}}
{{#isManyToOne}}
{{name}}LocalId: String? = nil,
{{/isManyToOne}}
{{/fields}}
) {
let item = {{entity}}(
{{#fields}}
{{^isId}}
{{name}}: {{name}},
{{/isId}}
{{/fields}}
)
item.user = user
item.reference = item.id

{{#fields}}
{{#isManyToOne}}
item.{{name}}LocalId = {{name}}LocalId
{{/isManyToOne}}
{{/fields}}

print("createEntity \(item.name)")
modelContext.insert(item)
saveContext()
}

func updateEntity(_ item: {{entity}},
{{#fields}}
	{{name}}: {{realType}},
    {{#isManyToOne}}
    {{name}}LocalId: String? = nil,
    {{/isManyToOne}}
{{/fields}}
) {
{{#fields}}
	item.{{name}} = {{name}}
{{#isManyToOne}}
    item.{{name}}LocalId = {{name}}LocalId
{{/isManyToOne}}
{{/fields}}

if item.remoteId == nil {
print("[updateEntity] remoteId is nil  \(item.name)")
item.status = .create
} else {
print("[updateEntity] local ok \(item.name)")
item.status = .update
}

item.reference = item.id
item.user = user
print("updated \(item.name)")
item.updatedAt = Date()
item.syncAt = nil
print("updateEntity \(item.name)")
saveContext()
}

func deleteEntity(_ item: {{entity}}) {
item.status = .delete
item.deletedAt = Date()
item.updatedAt = Date()
item.syncAt = nil

if item.remoteId == nil {
item.remoteId = "NOT_EXIST_YET"
print("Deleted \(item.name)")
modelContext.delete(item)
} else {
item.status = .delete
}

item.user = user
print("deleteEntity \(item.name)")
saveContext()
}

public func saveContext() {
do {
try modelContext.save()
} catch {
errorMessage = mapError(error)
}
}



}
