import SwiftUI
import SwiftData

final class {{entity}}ListViewModel: ObservableObject {
var modelContext: ModelContext
var user: User
let username: String

@Published var entities: [{{entity}}] = []
@Published var errorMessage: String?
@Published var isLoading: Bool = false
@Published var showSuccessToast = false
@Published var showErrorToast = false

init(modelContext: ModelContext, user: User) {
self.modelContext = modelContext
self.user = user
self.username = user.username!
}

func fetchEntities() {
print("[fetchEntities]")
isLoading = true
let cond = "{{entity}}Status.delete".uppercased()
let descriptor = FetchDescriptor<{{entity}}>(
predicate: #Predicate { item in
item.user?.username == username && item.statusRaw != cond
},
sortBy: [SortDescriptor(\.updatedAt, order: .reverse)]
)
do {
entities = try modelContext.fetch(descriptor)
} catch {
errorMessage = mapError(error)
}
isLoading = false
}


func createEntity(
{{#fields}}
{{^isId}}
{{name}}: {{realType}}{{#nullable}}? = nil{{/nullable}}{{^nullable}}{{#defaultValue}} = {{{defaultValue}}}{{/defaultValue}}{{/nullable}},
{{/isId}}
{{/fields}}
) {
let item = {{entity}}(
{{#fields}}
{{^isId}}
{{name}}: {{name}},
{{/isId}}
{{/fields}}
)
item.user = user
item.reference = item.id

print("createEntity \(item.name)")
modelContext.insert(item)
saveContext()
}

func updateEntity(_ item: {{entity}},
{{#fields}}
	{{name}}: {{realType}},
{{/fields}}
) {
{{#fields}}
	item.{{name}} = {{name}}
{{/fields}}

if item.remoteId == nil {
print("[updateEntity] remoteId is nil  \(item.name)")
item.status = .create
} else {
print("[updateEntity] local ok \(item.name)")
item.status = .update
}

item.reference = item.id
item.user = user
print("updated \(item.name)")
item.updatedAt = Date()
item.syncAt = nil
print("updateEntity \(item.name)")
saveContext()
}

func deleteEntity(_ item: {{entity}}) {
item.status = .delete
item.deletedAt = Date()
item.updatedAt = Date()
item.syncAt = nil

if item.remoteId == nil {
item.remoteId = "NOT_EXIST_YET"
print("Deleted \(item.name)")
modelContext.delete(item)
} else {
item.status = .delete
}

item.user = user
print("deleteEntity \(item.name)")
saveContext()
}

public func saveContext() {
do {
try modelContext.save()
} catch {
errorMessage = mapError(error)
}
}



}
