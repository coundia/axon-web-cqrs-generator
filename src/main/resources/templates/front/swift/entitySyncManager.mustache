import Foundation
import SwiftData

final class {{entity}}SyncManager {
    private let modelContext: ModelContext
    private let userId: UUID
    private let user: User

    init(modelContext: ModelContext, user: User) {
        self.modelContext = modelContext
        self.user = user
        self.userId = user.id
    }

    func pullAndMerge{{entity}}s() async throws {
        print("[{{entity}}SyncManager] üöÄ Starting pullAndMerge{{entity}}s")

        guard let token = TokenProvider.shared.getToken() else {
            print("[{{entity}}SyncManager] ‚ùå No token found")
            throw URLError(.userAuthenticationRequired)
        }

        let url = API{{entity}}.queryEndpoint

        print("[{{entity}}SyncManager] üåê Fetching from: \(url.absoluteString)")

        var request = URLRequest(url: url)
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")

        let (data, response) = try await URLSession.shared.data(for: request)

        guard let httpResponse = response as? HTTPURLResponse else {
            print("[{{entity}}SyncManager] ‚ùå Invalid HTTP response")
            throw URLError(.badServerResponse)
        }

        print("[{{entity}}SyncManager] üì° HTTP Status: \(httpResponse.statusCode)")

        if !(200..<300).contains(httpResponse.statusCode) {
            let message = String(data: data, encoding: .utf8) ?? "No response body"
            print("[{{entity}}SyncManager] ‚ùå Server error: \(message)")
            throw URLError(.badServerResponse)
        }

        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .custom { decoder in
            let container = try decoder.singleValueContainer()
            let dateString = try container.decode(String.self)
            let formats = [
                "yyyy-MM-dd'T'HH:mm:ss.SSSSSSZ",
                "yyyy-MM-dd'T'HH:mm:ss.SSSZ",
                "yyyy-MM-dd'T'HH:mm:ssZ"
            ]
            for format in formats {
                let formatter = DateFormatter()
                formatter.dateFormat = format
                formatter.locale = Locale(identifier: "en_US_POSIX")
                formatter.timeZone = TimeZone(secondsFromGMT: 0)
                if let date = formatter.date(from: dateString) {
                    return date
                }
            }
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Cannot decode date: \(dateString)")
        }

        do {
            let remote = try decoder.decode({{entity}}PagedResponse.self, from: data)
            print("[{{entity}}SyncManager] ‚úÖ Remote items: \(remote.content.count)")

            let existing = try modelContext.fetch(
                FetchDescriptor<{{entity}}>(predicate: #Predicate { $0.user?.id == userId })
            )
            print("[{{entity}}SyncManager] üóÇ Local items: \(existing.count)")

            for remoteItem in remote.content {
                if let local = existing.first(where: { $0.reference == remoteItem.reference }) {
                    if let remoteUpdatedAt = remoteItem.updatedAt,
                       let localUpdatedAt = local.updatedAt,
                       remoteUpdatedAt <= localUpdatedAt {
                        local.remoteId = remoteItem.id
                        print("[{{entity}}SyncManager] ‚è© Skipped: \(local.name)")
                        try modelContext.save()
                        continue
                    }

                    print("[{{entity}}SyncManager] üîÑ Updating: \(local.name)")
                    {{#fields}}
	{{^isId}}
		{{#isParentRelation}}
                    // skip parent relation
                    {{/isParentRelation}}
		{{^isParentRelation}}
                    local.{{name}} = remoteItem.{{name}}
		{{/isParentRelation}}
	{{/isId}}
{{/fields}}
                    local.status = {{entity}}Status.sync
                    local.syncAt = Date()
                } else {
                    print("[{{entity}}SyncManager] ‚ûï Creating new: \(remoteItem.name)")
                    let newItem = {{entity}}(
                        {{#fields}}
	{{#isId}}{{/isId}}{{^isId}}
		{{name}}: remoteItem.{{name}},
                        {{/isId}}
{{/fields}}
                    )
                    newItem.user = user
                    newItem.remoteId = remoteItem.id
                    newItem.syncAt = Date()
                    newItem.status = {{entity}}Status.sync
                    newItem.statusRaw = {{entity}}Status.sync.rawValue
                    modelContext.insert(newItem)
                }
            }

            try modelContext.save()
            print("[{{entity}}SyncManager] üíæ Saved")
        } catch {
            let raw = String(data: data, encoding: .utf8) ?? "<no body>"
            print("[{{entity}}SyncManager] ‚ùå Decode error: \(error)")
            print("[{{entity}}SyncManager] ‚ùå Raw: \(raw)")
            throw error
        }
    }
}
