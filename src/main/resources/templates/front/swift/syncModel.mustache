import SwiftUI
import SwiftData

extension {{entity}}ListViewModel {

    func pull() async {
        print("[pullEntities]")
            let manager = {{entity}}PullService(modelContext: modelContext, user: user)
            do {
            try await manager.pullAndMerge{{entity}}s()
            } catch {
            await MainActor.run {
                errorMessage = mapError(error)
                showErrorToast = true
            }
        }
    }

     func sync() async {
        print("[syncEntities]")
             do {
            try
                await pull()
                await MainActor.run { _ = fetchEntitiesUnSynced() }
                await syncAllEntities()
                await pull()

            } catch {
            await MainActor.run {
                errorMessage = mapError(error)
                showErrorToast = true
            }
        }
    }

    func syncAllEntities() async {
        let unsynced = fetchEntitiesUnSynced()

        let deltas: [{{entity}}DeltaDto] = unsynced.map {
        {{entity}}DeltaDto(
        id: $0.remoteId ?? "null",
        {{#fields}}
            {{^isId}}
                {{name}}: $0.{{name}},
        {{/isId}}
        {{/fields}}
        type: $0.statusRaw
        )
        }

        let useCase = Sync{{entity}}UseCase()
        do {
             try await useCase.execute(with: deltas)
        for item in unsynced {
         item.syncAt = Date()
            if(item.status != .sync && item.status != .delete && item.status != .trash   ) {
                item.status = .syncing
            }

            if item.status == .delete || item.status == .trash {
                 item.status = .trash
            }

        }
         saveContext()
          await MainActor.run { self.showSuccessToast = true }
        } catch {
            await MainActor.run {
                self.errorMessage = mapError(error)
                self.showErrorToast = true
            }
        }
    }


    func fetchEntitiesUnSynced() -> [{{entity}}] {
            print("[fetchEntitiesUnSynced]")
             let descriptor = FetchDescriptor<{{entity}}>(
              predicate: #Predicate {
                      $0.user?.username == username
                      && $0.statusRaw != "SYNC"
                      && $0.statusRaw != "SYNCING"
                      && $0.statusRaw != "TRASH"
            },
                sortBy: [SortDescriptor(\.updatedAt, order: .reverse)]
            )
            do {
              return try modelContext.fetch(descriptor)
            } catch {
            errorMessage = mapError(error)
            return []
        }
        }

    @MainActor
    func pullAndSync(entity: {{entity}}) async {
        print("[checkStatusFromApiAndUpdate] üöÄ Start")

        guard let id = entity.remoteId else {
            print("[checkStatusFromApiAndUpdate] ‚ö†Ô∏è remoteId is nil")
            return
        }

        guard let token = TokenProvider.shared.getToken() else {
            print("[checkStatusFromApiAndUpdate] ‚ùå Missing token")
            return
        }

        let urlString = "http://127.0.0.1:8095/api/v1/queries/{{entityLowerCase}}/id?id=\(id)"
        guard let url = URL(string: urlString) else {
            print("[checkStatusFromApiAndUpdate] ‚ùå Invalid URL")
            return
        }

        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.setValue("application/json", forHTTPHeaderField: "Accept")
        request.setValue("Bearer \(token)", forHTTPHeaderField: "Authorization")

        do {
            let (data, response) = try await URLSession.shared.data(for: request)

            guard let httpResponse = response as? HTTPURLResponse else {
                print("[checkStatusFromApiAndUpdate] ‚ùå Invalid HTTP response")
                return
            }

            print("[checkStatusFromApiAndUpdate] üì° HTTP Status: \(httpResponse.statusCode)")

            if !(200..<300).contains(httpResponse.statusCode) {
                let raw = String(data: data, encoding: .utf8) ?? "<no body>"
                print("[checkStatusFromApiAndUpdate] ‚ùå Server error: \(raw)")
                return
            }

            let decoder = JSONDecoder()
            decoder.dateDecodingStrategy = .iso8601

            let remote = try decoder.decode({{entity}}DeltaDto.self, from: data)

            print("[checkStatusFromApiAndUpdate] ‚úÖ Received remote id: \(remote.id)")

            entity.status = .sync
            entity.statusRaw = {{entity}}Status.sync.rawValue
            entity.syncAt = Date()
            try modelContext.save()

            print("[checkStatusFromApiAndUpdate] ‚úÖ Updated local status to SYNC")

        } catch {
            print("[checkStatusFromApiAndUpdate] ‚ùå Error: \(error.localizedDescription)")
            self.errorMessage = mapError(error)
            self.showErrorToast = true
        }
    }


}