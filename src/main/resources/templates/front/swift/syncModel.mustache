import SwiftUI
import SwiftData

extension {{entity}}ListViewModel {

    func pull() async {
        print("[pullEntities]")
            let manager = {{entity}}PullService(modelContext: modelContext, user: user)
            do {
            {{^transactional}}
            try await manager.pullAndMerge{{entity}}s()
            {{/transactional}}
            {{#transactional}}
            try await manager.pullAndMerge{{entity}}sByAccount(accountId: currentAccountId ?? "")
            {{/transactional}}


            } catch {
            await MainActor.run {
                errorMessage = mapError(error)
                showErrorToast = true
            }
        }
    }

     func sync() async {
        print("[syncEntities]")
             do {
            try
                await pull()
                await MainActor.run { _ = fetchEntitiesUnSynced() }
                await syncAllEntities()
                try? await Task.sleep(nanoseconds: 1_000_000_000)
                await pull()
                await pull()

                await MainActor.run {
                     fetchEntities()
                 }

            } catch {
            await MainActor.run {
                errorMessage = mapError(error)
                showErrorToast = true
            }
        }
    }

    func syncAllEntities() async {
        let unsynced = fetchEntitiesUnSynced()

        let deltas: [{{entity}}DeltaDto] = unsynced.map {
        {{entity}}DeltaDto(
        id: $0.remoteId ?? "null",
        {{#fields}}
    {{^isId}}
        {{name}}: $0.{{name}},
        {{/isId}}
{{/fields}}
        type: $0.statusRaw
        )
        }

        let useCase = Sync{{entity}}UseCase()
        do {
             try await useCase.execute(with: deltas)
        for item in unsynced {
         item.syncAt = Date()
            if(item.status != .sync && item.status != .delete && item.status != .trash   ) {
                item.status = .syncing
            }

            if item.status == .delete || item.status == .trash {
                 item.status = .trash
            }

        }
         saveContext()
          await MainActor.run { self.showSuccessToast = true }
        } catch {
            await MainActor.run {
                self.errorMessage = mapError(error)
                self.showErrorToast = true
            }
        }
    }


    func fetchEntitiesUnSynced() -> [{{entity}}] {
            print("[fetchEntitiesUnSynced]")
             let descriptor = FetchDescriptor<{{entity}}>(
              predicate: #Predicate {
                      $0.user?.username == username
                      && $0.statusRaw != "SYNC"
                      && $0.statusRaw != "SYNCING"
                      && $0.statusRaw != "TRASH"
            },
                sortBy: [SortDescriptor(\.updatedAt, order: .reverse)]
            )
            do {
              return try modelContext.fetch(descriptor)
            } catch {
            errorMessage = mapError(error)
            return []
        }
        }

     public func sync(entity: {{entity}} ) async {

        print("[syncEntity] \(entity.name)")

        if(entity.remoteId != nil) {
            entity.status = .update
        }

        if(entity.remoteId == nil) {
            entity.status = .create
        }

        let delta = {{entity}}DeltaDto(
            {{#fields}}
    {{#isId}}
                        id: entity.remoteId ?? "",
                        {{/isId}}
    {{^isId}}
        {{#isText}}
            {{name}}: entity.{{name}} ?? "",
                        {{/isText}}
        {{#isDouble}}
            {{name}}: entity.{{name}},
                        {{/isDouble}}
        {{#isBool}}
            {{name}}: entity.{{name}},
                        {{/isBool}}
        {{#isDate}}
            {{name}}: entity.{{name}},
                        {{/isDate}}
    {{/isId}}
{{/fields}}
            type: entity.status.rawValue
        )

        do {
            try await Sync{{entity}}UseCase().execute(with: [delta])
            //errorMessage = "âœ… Success !"

            entity.status = .syncing
             saveContext()

            try? await Task.sleep(nanoseconds: 1_000_000_000)
                 await  pull()

           // await MainActor.run { self.showSuccessToast = true }

        } catch {
              await MainActor.run {
                self.errorMessage = mapError(error)
                self.showErrorToast = true
            }
        }
    }


}