import { inject, Injectable, signal } from '@angular/core';
import { Observable, forkJoin, from, of } from 'rxjs';
import { map, tap, catchError } from 'rxjs/operators';
import { DatabaseService } from '../../../shared/services/database.service';
import { AlertService } from '../../../shared/components/alert/alert.service';
import type { {{entityCapitalized}} } from '../models/{{entityLowerCase}}.model';
import {  getColumnsToInsert } from '../../../shared/hooks/get-column';
import { generateId } from '../../../shared/hooks/generator';

const TABLE_NAME = '{{table}}';

@Injectable({ providedIn: 'root' })
export class {{entityCapitalized}}Service {
  private db = inject(DatabaseService);
  private alert = inject(AlertService);

  {{entityPluralLower}} = signal<{{entityCapitalized}}[]>([]);
  {{entityLowerCase}}All = signal<{{entityCapitalized}}[]>([]);
  selected{{entityCapitalized}} = signal<{{entityCapitalized}} | null>(null);
  totalPages = signal(0);
  totalElements = signal(0);

  fetch(page = 0, limit = 10): Observable<{ content: {{entityCapitalized}}[]; totalPages: number; totalElements: number }> {
    const offset = page * limit;
    return forkJoin({
      content: from(this.db.select<{{entityCapitalized}}>(`SELECT * FROM ${TABLE_NAME} order by updatedAt DESC LIMIT ? OFFSET ?`, [limit, offset])),
      countRows: from(this.db.select<{ count: number }>(`SELECT COUNT(*) AS count FROM ${TABLE_NAME}`, []))
    }).pipe(
      map(({ content, countRows }) => {
        const total = countRows[0]?.count ?? 0;
        return { content, totalPages: Math.ceil(total / limit), totalElements: total };
      }),
      tap(({ content, totalPages, totalElements }) => {
        this.{{entityPluralLower}}.set(content);
        this.totalPages.set(totalPages);
        this.totalElements.set(totalElements);
      }),
      catchError(err => {
        console.error(err);
        this.alert.show(`Erreur lors du chargement des {{entityPluralLower}} !`, 'error');
        return of({ content: [], totalPages: 0, totalElements: 0 });
      })
    );
  }

  private getColumns(dto: Partial<{{entityCapitalized}}>): string[] {

    const ignoredCols = [];
     {{#shouldGenerateId}}
    ignoredCols.push("id");
    {{/shouldGenerateId}}

    const cols = getColumnsToInsert(dto);

    ignoredCols.forEach(col => {
      const index = cols.indexOf(col);
      if (index !== -1) {
        cols.splice(index, 1);
      }
    });

    return cols;
  }

  create(dto: Partial<{{entityCapitalized}}>, page = 0, limit = 10): Observable<void> {
    const cols = this.getColumns(dto);
    const sql = `INSERT INTO ${TABLE_NAME} (${cols.join(',')}) VALUES (${cols.map(() => '?').join(',')})`;
    const params = cols.map(k => (dto as any)[k]);

    return from(this.db.execute(sql, params)).pipe(
      tap(() => {
        this.fetch(page, limit).subscribe();
      }),
      map(() => undefined),
      catchError(err => {
        console.error(err);
        this.alert.show(`Erreur création {{entityLowerCase}}!`, 'error');
        throw err;
      })
    );
  }

  update(id: string, dto: Partial<{{entityCapitalized}}>, page = 0, limit = 10): Observable<void> {
    const cols = this.getColumns(dto);
    const sql = `UPDATE ${TABLE_NAME} SET ${cols.map(k => `${k} = ?`).join(',')} WHERE id = ?`;
    const params = [...cols.map(k => (dto as any)[k]), id];

    return from(this.db.execute(sql, params)).pipe(
      tap(() => {
         this.fetch(page, limit).subscribe();
      }),
      map(() => undefined),
      catchError(err => {
        console.error(err);
        this.alert.show(`Erreur mise à jour {{entityLowerCase}} !`, 'error');
        throw err;
      })
    );
  }

  delete(id: string, page = 0, limit = 10): Observable<void> {
    return from(this.db.execute(`DELETE FROM ${TABLE_NAME} WHERE id = ?`, [id])).pipe(
      tap(() => {
         this.fetch(page, limit).subscribe();
      }),
      map(() => undefined),
      catchError(err => {
        console.error(err);
        this.alert.show(`Erreur suppression {{entityLowerCase}} !`, 'error');
        throw err;
      })
    );
  }

  search(field: string, value: string): Observable<{{entityCapitalized}}[]> {
    return from(this.db.select<{{entityCapitalized}}>(`SELECT * FROM ${TABLE_NAME} WHERE ${field} like ? ORDER BY updatedAt DESC`, ['%'+value+'%'])).pipe(
      tap(rows => this.{{entityPluralLower}}.set(rows)),
      catchError(err => {
        console.error(err);
        this.alert.show(`Erreur recherche {{entityLowerCase}} !`, 'error');
        return of([]);
      })
    );
  }

  getById(id: string): Observable<{{entityCapitalized}} | null> {
    return from(this.db.select<{{entityCapitalized}}>(`SELECT * FROM ${TABLE_NAME} WHERE id = ? ORDER BY updatedAt DESC`, [id])).pipe(
      map(rows => rows[0] ?? null),
      tap(item => this.selected{{entityCapitalized}}.set(item)),
      catchError(err => {
        console.error(err);
        this.alert.show(`Erreur chargement {{entityLowerCase}} !`, 'error');
        return of(null);
      })
    );
  }

 fetchAll(): Observable<{{entity}}[]> {
    return from(this.db.select<{{entity}}>(`SELECT * FROM ${TABLE_NAME} ORDER BY updatedAt DESC`)).pipe(
        tap(rows => this.{{entityLowerCase}}All.set(rows)),
        catchError(err => {
          console.error(err);
          this.alert.show(`Erreur lors du chargement complet des {{entityPluralLower}} !`, 'error');
          return of([]);
        })
    );
  }

    currentPage = signal(0);
    searchField = signal<string | null>(null);
    searchValue = signal<string | null>(null);

    setPage(page: number): void {
        this.currentPage.set(page);
        const field = this.searchField();
        const value = this.searchValue();

        if (field && value) {
            this.searchWithPagination(field, value, page).subscribe();
        } else {
            this.fetch(page).subscribe();
        }
    }


    nextPage(): void {
        const next = this.currentPage() + 1;
        if (next < this.totalPages()) {
            this.setPage(next);
        }
    }

    previousPage(): void {
        const prev = this.currentPage() - 1;
        if (prev >= 0) {
            this.setPage(prev);
        }
    }

    refresh(): void {
        this.refresh$().subscribe();
    }

    refresh$(): Observable<{ content: {{entity}}[]; totalPages: number; totalElements: number }> {
       return this.fetch(this.currentPage());
    }

  searchWithPagination(field: string, value: string, page = 0, limit = 10): Observable<{
        readonly content?: any;
        readonly totalPages?: any;
        readonly totalElements?: any
    }> {
        const offset = page * limit;

        return forkJoin({
            content: from(this.db.select<{{entity}}>(`SELECT * FROM ${TABLE_NAME} WHERE ${field} like ? ORDER BY updatedAt DESC LIMIT ? OFFSET ?`, ['%'+value+'%', limit, offset])),
            countRows: from(this.db.select<{ count: number }>(`SELECT COUNT(*) AS count FROM ${TABLE_NAME} WHERE ${field} like ? `, ['%'+value+'%']))
        }).pipe(
            map(({ content, countRows }) => {
                const total = countRows[0]?.count ?? 0;
                return { content, totalPages: Math.ceil(total / limit), totalElements: total };
            }),
            tap(({ content, totalPages, totalElements }) => {
                this.{{entityPluralLower}}.set(content);
                this.totalPages.set(totalPages);
                this.totalElements.set(totalElements);
                this.searchField.set(field);
                this.searchValue.set(value);
                this.currentPage.set(page);
            }),
            catchError(err => {
                console.error(err);
                this.alert.show(`Erreur recherche paginée !`, 'error');
                return of();
            })
        );
    }

    generate{{entity}}Id(): string {
      const prefix = '{{entity}}'.slice(0, 2).toUpperCase();
      return generateId(prefix);
    }

    deleteAll(
    ): Observable<void> {

        let field = this.searchField();
        let value = this.searchValue();

        if(!field || !value) {
            this.alert.show('Aucun critère de recherche défini !', 'error');
            return of(undefined);
        }

        const query = `DELETE FROM ${TABLE_NAME} WHERE ${field} like ?`;

        return from(
            this.db.execute(
                query,[`%${value}%`]
            )
        ).pipe(
            tap(() => {
                 this.refresh();
            }),
            map(() => undefined),
            catchError(err => {
                console.error(err);
                this.alert.show('Erreur suppression par critère !', 'error');
                throw err;
            })
        );
    }

     {{#linkedItems}}
      get{{childModel}}ById(parentId: string): Promise<{{childModel}}[]> {
        return this.db
            .select<{{childModel}}>('SELECT * ' +
                '        FROM {{childTableName}}  \n' +
                '        WHERE  {{entityLowerCase}} = ? ORDER BY updatedAt DESC', [parentId])
            .then(items => items)
            .catch(err => {
                console.error(err);
                this.alert.show(err , 'error');
                return [];
            });
        }
      {{/linkedItems}}

}
