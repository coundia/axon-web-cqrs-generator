package {{package}};

{{#imports}}
import {{.}};
{{/imports}}


import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.axonframework.commandhandling.gateway.CommandGateway;
import org.axonframework.queryhandling.QueryGateway;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.concurrent.CompletableFuture;

@Slf4j
@Service
@RequiredArgsConstructor
public class RefreshTokenService {

private final JwtDecoder jwtDecoder;
private final CommandGateway commandGateway;
private final QueryGateway queryGateway;

public void save(String token) {
try {
Jwt jwt = jwtDecoder.decode(token);
String username = jwt.getSubject();
Instant expiration = jwt.getExpiresAt();

try {

MetaRequest metaRequest = new MetaRequest();

metaRequest.setUserId(RequestContext.getUserId(jwt));
metaRequest.setTenantId(RequestContext.getTenantId(jwt));

CompletableFuture<RefreshTokenResponse> future = queryGateway.query(
		new FindByRefreshTokenUsernameQuery(RefreshTokenUsername.create(username), metaRequest),
		RefreshTokenResponse.class
	);

	RefreshTokenResponse existing = future.join();
		if(existing!= null) {
			commandGateway.sendAndWait(new DeleteRefreshTokenCommand(RefreshTokenId.create(existing.getId())));
		}
 	} catch (Exception e) {
		e.printStackTrace();
		log.info("No existing refresh token found for {}. Proceeding to save new.", username);
	}

	commandGateway.sendAndWait(CreateRefreshTokenCommand.builder()
	.token(RefreshTokenToken.create(token))
	.username(RefreshTokenUsername.create(username))
	.expiration(RefreshTokenExpiration.create(expiration))
	.build());

	} catch (Exception e) {
		e.printStackTrace();
		log.error("Error while saving refresh token: {}", e.getMessage(), e);
	}
	}

 }
